/*******************************************************************
 * File:        fpa
 * Purpose:     Disassembly for the Floating Point Accelerator instructions
 * Author:      Gerph
 * Date:        20 Jul 2025
 ******************************************************************/

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#include "darm.h"

#include "fpa.h"

static const char *immediates[] = {
    "#0", "#1", "#2", "#3", "#4", "#5", "#0.5", "#10"
};

static const char *fpregs[] = {
    "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7"
};

static const char *fpdo_mnemonic[] = {
    "ADF",  // ... binary ops
    "MUF",
    "SUF",
    "RSF",
    "DVF",
    "RDF",
    "POW",
    "RPW",
    "RMF",
    "FML",
    "FDV",
    "FRD",
    "POL",
    "F0D",  // ... undefined binary ops
    "F0E",
    "F0F",
    "MVF",  // ... unary ops
    "MNF",
    "ABS",
    "RND",
    "SQT",
    "LOG",
    "LGN",
    "EXP",
    "SIN",
    "COS",
    "TAN",
    "ASN",
    "ACS",
    "ATN",
    "URD",
    "NRM",
};


/*************************************************** Gerph *********
 Function:      operand_fm
 Description:   Decode an floating point operand register
 Parameters:    word = the word to decode
 Returns:       pointer to the operand string
 ******************************************************************/
static const char *operand_fm(uint32_t word)
{
    bool immediate = word & 8;
    int value = (word & 7);
    if (immediate)
    {
        return immediates[value];
    }
    else
    {
        return fpregs[value];
    }
}


/*************************************************** Gerph *********
 Function:      conditioncode
 Description:   Return the condition code string for a value
 Parameters:    cc = condition code
 Returns:       pointer to the condition code string
 ******************************************************************/
static const char *conditioncode(uint32_t cc)
{
    const char *str = darm_condition_name((darm_cond_t)cc, 1);
    return str ? str : "";
}

/*************************************************** Gerph *********
 Function:      armregname
 Description:   Return the string for an ARM register
 Parameters:    armreg = the register to return
 Returns:       pointer to the arm register string
 ******************************************************************/
static const char *armregname(uint32_t armreg)
{
    return darm_register_name((darm_reg_t)armreg);
}


/*************************************************** Gerph *********
 Function:      disassemble_fpa
 Description:   Disassemble a FPA instruction into a string
 Parameters:    address = the address we're decoding at
                word = the 32bit ARM word to disassemble
                buffer-> where to write the disassembly
                bufferlen = length of the buffer
 Returns:       true on success, false on failure.
 ******************************************************************/
bool disassemble_fpa(uint32_t address, uint32_t word, char *buffer, int bufferlen)
{
    uint32_t opcode = (word>>24) & 15;
    char *out = buffer;
    char *end = buffer + bufferlen;

#define ACCUMULATE(c) do { if (out < end) *out++ = (c); else out++; } while (0)

    if ((opcode == 12 || opcode == 13) &&
        ((word>>8) & 15) == 1)
    {
        /* LDF/STF
         * format is        cccc 110p uywl nnnn xddd 0001 iiii iiii
         *
         * <LDF|STF>{cond}<S|D|E|P> Fd,[Rn,#imm]{!}
         * <LDF|STF>{cond}<S|D|E|P> Fd,[Rn],#imm
         *
         * where cccc = condition
         *          p = Pre-indexing/~Post-indexing
         *          u = Up/~Down
         *         yx = transfer length (S,D,E or P)
         *          w = Writeback
         *          l = Load/~Store
         *       nnnn = Rn
         *        ddd = Fd
         *   iiiiiiii = 8-bit immediate offset
         */
        const char *cc = conditioncode(word >> 28);
        const char *mnemonic = (word & (1<<20)) ? "LDF" : "STF";

        // Length bits are not contiguous
        const char length = "SDEP"[((word >> 21) & 2) + ((word >> 15) & 1)];
        bool preindex = word & (1<<24);
        bool up = word & (1<<23);
        uint32_t armreg = (word>>16) & 15;
        uint32_t fpreg = (word>>12) & 7;
        int32_t offset = (word & 255) * 4;
        bool writeback = word & (1<<21);

        if (! up)
            offset = -offset;

        out += snprintf(out, end - out, "%s%s%c", mnemonic, cc, length);
        out += snprintf(out, end - out, "%*s", 8 - (out-buffer), "");
        out += snprintf(out, end - out, "%s, ", fpregs[fpreg]);

        if (preindex)
        {
            if (armreg == 15)
            {
                out += snprintf(out, end - out, "&%08x", address + 8 + offset);
            }
            else
            {
                if (offset == 0)
                {
                    out += snprintf(out, end - out, "[%s]", armregname(armreg));
                    if (writeback)
                        ACCUMULATE('!');
                }
                else
                {
                    out += snprintf(out, end - out, "[%s, #%i]", armregname(armreg), offset);
                    if (writeback)
                        ACCUMULATE('!');
                }
            }
        }
        else
        {
            out += snprintf(out, end - out, "[%s], #%i", armregname(armreg), offset);
        }
    }
    else if ((opcode == 12 || opcode == 13) &&
             ((word>>8) & 15) == 2)
    {
        /* LFM/SFM
         * format is        cccc 110p uywl nnnn xddd 0010 iiii iiii
         *
         * <LFM|SFM>{cond} Fd,count,[Rn, #imm]{!}
         * <LFM|SFM>{cond} Fd,count,[Rn],#imm
         *
         * where cccc = condition
         *          p = Pre-indexed/~Post-indexed
         *          u = Up/~Down
         *         yx = register count (4,1,2 or 3)
         *          w = Writeback
         *          l = Load/~Store
         *       nnnn = Rn
         *        ddd = Fd
         *   iiiiiiii = immediate offset
         */
        const char *cc = conditioncode(word >> 28);
        const char *mnemonic = (word & (1<<20)) ? "LFM" : "SFM";

        // Count bits are not contiguous
        int count = (((word >> 21) & 2) + ((word >> 15) & 1));
        bool preindex = word & (1<<24);
        bool up = word & (1<<23);
        uint32_t armreg = (word>>16) & 15;
        uint32_t fpreg = (word>>12) & 7;
        int32_t offset = (word & 255) * 4;
        bool writeback = word & (1<<21);

        if (! up)
            offset = -offset;

        out += snprintf(out, end - out, "%s%s", mnemonic, cc);
        out += snprintf(out, end - out, "%*s", 8 - (out-buffer), "");
        out += snprintf(out, end - out, "%s, %i, ", fpregs[fpreg], count);

        if (preindex)
        {
            if (armreg == 15)
            {
                out += snprintf(out, end - out, "&%08x", address + 8 + offset);
            }
            else
            {
                if (offset == 0)
                {
                    out += snprintf(out, end - out, "[%s]", armregname(armreg));
                    if (writeback)
                        ACCUMULATE('!');
                }
                else
                {
                    out += snprintf(out, end - out, "[%s, #%i]", armregname(armreg), offset);
                    if (writeback)
                        ACCUMULATE('!');
                }
            }
        }
        else
        {
            out += snprintf(out, end - out, "[%s], #%i", armregname(armreg), offset);
        }
    }
    else if (opcode == 14 &&
             ((word>>8) & 15) == 1 &&
             ((word>>4) & 1) == 0)
    {
        /* format is        cccc 1110 abcd ennn jddd 0001 fgh0 immm
         *
         * <Dyadic op>{cond}<S|D|E>{P|M|Z} Fd,Fn,<Fm|#constant>
         * <Monadic op>{cond}<S|D|E>{P|M|Z} Fd,<Fm|#constant>
         *
         * where cccc = condition
         *       abcd = opcode
         *         ef = destination size
         *         gh = rounding mode
         *       immm = Fm/constant
         *        nnn = Fn
         *        ddd = Fd
         *          j = Monadic/~Dyadic
         */
        uint32_t opcode = (word >> 20) & 15;
        char length = "SDEx"[((word>>18) & 2) + ((word>>7) & 1)];
        // length 3 is invalid
        char rounding = " PMZ"[(word>>5) & 3];
        // rounding 0 has no symbol?
        uint32_t fpregn = (word >> 16) & 7;
        uint32_t fpregd = (word >> 12) & 7;
        uint32_t monadic = (word>>15) & 1;
        const char *cc = conditioncode(word >> 28);
        const char *mnemonic = fpdo_mnemonic[opcode | (monadic<<4)];
        const char *operand;

        out += snprintf(out, end - out, "%s%s%c%c", mnemonic, cc, length, rounding);
        out += snprintf(out, end - out, "%*s", 8 - (out-buffer), "");

        operand = operand_fm(word);
        if (monadic)
        {
            out += snprintf(out, end - out, "%s, %s", fpregs[fpregd], operand);
        }
        else
        {
            out += snprintf(out, end - out, "%s, %s, %s", fpregs[fpregd], fpregs[fpregn], operand);
        }
    }
    else if (opcode == 14 &&
             ((word>>8) & 15) == 1 &&
             ((word>>4) & 1) == 1)
    {
        uint32_t opcode = (word >> 20) & 7;
        uint32_t status = (word & (9<<20)) == (9<<20);
        uint32_t invalid = (word & (9<<20)) == (8<<20);
        if (status)
        {
            /* format is        cccc 1110 1en1 0nnn 1111 0001 0001 immm
             *
             * <CMF|CNF>{E}{cond} Fn,Fm
             * <CMF|CNF>{E}{cond} Fn,#constant
             *
             * where cccc = condition
             *          e = Exception
             *          n = CNF/~CMF
             *        nnn = Fn
             *       immm = Fm/constant
             */
            bool excepting = word & (1<<22);
            bool negated = word & (1<<21);
            uint32_t fpregn = (word>>16) & 7;
            const char *cc = conditioncode(word >> 28);
            const char *mnemonic = negated ? "CNF" : "CMF";
            const char *excepting_str = excepting ? "E" : "";
            const char *operand = operand_fm(word);

            out += snprintf(out, end - out, "%s%s%s", mnemonic, excepting_str, cc);
            out += snprintf(out, end - out, "%*s", 8 - (out-buffer), "");
            out += snprintf(out, end - out, "%s, %s", fpregs[fpregn], operand);
        }
        else if (invalid)
        {
            /* We don't decode this invalid sequence */
            return false;
        }
        else
        {
            /* format is        cccc 1110 abcl ennn dddd 0001 fgh1 0mmm
             *
             * FLT{cond}<S|D|E>{P|M|Z} Fn,Rd
             * FIX{cond}{P|M|Z}        Rd,Fm
             * <WFS|RFS|WFC|RFC>{cond} Rd
             *
             * where cccc = condition
             *          l = Load/~Store
             *        abc = operation            abcl         abcl
             *                                   0000 FLT     0001 FIX
             *                                   0010 WFS     0011 RFS
             *                                   0100 WFC     0101 RFC
             *                                                1xx1 may be compare
             *         ef = destination size (FLT only)
             *         gh = rounding mode (FLT and FIX only)
             *        nnn = Fn (FLT only)
             *        mmm = Fm (FIX only)
             *       dddd = Rd
             */

            char length = "SDEx"[((word>>18) & 2) + ((word>>7) & 1)];
            // length 3 is invalid
            char rounding = " PMZ"[(word>>5) & 3];
            const char *cc = conditioncode(word >> 28);
            uint32_t armreg = (word>>12) & 15;

            if (opcode == 0)
            {
                out += snprintf(out, end - out, "FLT");
            }
            else if (opcode == 1)
            {
                out += snprintf(out, end - out, "FIX");
                length = '\0';
            }
            else if (opcode > 5)
            {
                out += snprintf(out, end - out, "xx%i", opcode);
            }
            else
            {
                ACCUMULATE((opcode & 1) ? 'R' : 'W');
                ACCUMULATE('F');
                ACCUMULATE((opcode & 4) ? 'C' : 'S');
                length = '\0';
                rounding = ' ';
            }

            out += snprintf(out, end - out, "%s", cc);
            if (length)
                ACCUMULATE(length);
            ACCUMULATE(rounding);

            out += snprintf(out, end - out, "%*s", 8 - (out-buffer), "");

            if (opcode == 0)
            {
                uint32_t fpregn = (word>>16) & 7;
                out += snprintf(out, end - out, "%s, %s", fpregs[fpregn], armregname(armreg));
            }
            else if (opcode == 1)
            {
                uint32_t fpregm = (word>>0) & 7;
                out += snprintf(out, end - out, "%s, %s", armregname(armreg), fpregs[fpregm]);
            }
            else if (opcode < 6)
            {
                out += snprintf(out, end - out, "%s", armregname(armreg));
            }
        }
    }
    else
    {
        return false;
    }
    ACCUMULATE('\0');
    return (out <= end) ? true : false;
}
