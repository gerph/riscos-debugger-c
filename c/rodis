/*******************************************************************
 * File:        rodis
 * Purpose:     RISCOS Disassembly veneers for other libraries
 * Author:      Gerph
 * Date:        16 Jun 2024
 ******************************************************************/

#include <string.h>
#include <stdio.h>
#include <ctype.h>

#include "swis.h"

#include "darm.h"
#include "armadillo.h"

#include "fpa.h"

static darm_t d;
static darm_str_t str;

/* Enable for debugging in this file */
//#define DEBUG

#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif

/* String to use when not recognised */
#define UNDEFINED_INSTRUCTION "Undefined instruction"

typedef enum immtype_e {
    it_positive,
    it_negative,
    it_negated
} immtype_t;

#define NEW_COMMENT \
    do { \
        if (comment == NULL) \
        { \
            strcpy(commentbuf, "#"); \
            comment = commentbuf; \
            offset = 1; \
        } \
        else \
        { \
            strcat(comment, " = "); \
            offset += 3; \
        } \
    } while (0)


static const char *decode_immediate(uint32_t imm, immtype_t it)
{
    static char commentbuf[128];
    char *comment = NULL;
    int offset = 0;
    int shift;
    if (it == it_negated)
        imm = ~imm;
    else if (it == it_negative)
        imm = -imm;

    if (imm < 0x100)
    {
        if (imm >= ' ' && imm <= 0x7f)
        {
            NEW_COMMENT;
            offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "'%c'", imm);
        }
    }
    else if (imm < 0x1000 && imm > 0x100)
    {
        /* Darm will have produced the constant as a decimal; we'll create the hex version */
        NEW_COMMENT;
        offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "&%x", imm);
    }
    else
    {
        /* Darm will have produced the constant as a hex value; we'll create the decimal one */
        NEW_COMMENT;
        if (it == it_positive)
            offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "%u", imm);
        else
            offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "%i", imm);
    }

    if (imm > 256)
    {
        for (shift = 4; shift < 32; shift += 4)
        {
            uint32_t value = (imm >> shift);
            if (imm & ((1<<shift)-1))
                break; /* There is a bit set below our sliding window, so we're done */
            if (value < 256)
            {
                NEW_COMMENT;
                offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "%i<<%i", value, shift);
                break;
            }
        }
    }
    if (imm > 10 && (imm & (imm-1)) == 0)
    {
        /* Only 1 bit is set, so we can try looking for it */
        uint32_t value = imm;
        shift = 0;
        if (value >= (1<<16)) {
            value = value >> 16, shift += 16;
        }
        if (value >= (1<<8)) {
            value = value >> 8, shift += 8;
        }
        if (value >= (1<<4)) {
            value = value >> 4, shift += 4;
        }
        if (value >= (1<<2)) {
            value = value >> 2, shift += 2;
        }
        if (value >= (1<<1)) {
            value = value >> 1, shift += 1;
        }
        NEW_COMMENT;
        offset += snprintf(&commentbuf[offset], sizeof(commentbuf) - offset, "bit %i", shift);
    }

    return comment;
}

/*************************************************** Gerph *********
 Function:      convert_hex_0x_to_ampersand
 Description:   Convert the 0x<number> sequence to RISC OS style &<number>
 Parameters:    str-> the string to modify in place
 Returns:       pointer to the start of the string
 ******************************************************************/
static char *convert_hex_0x_to_ampersand(char *str)
{
    char *zerox;
    while ((zerox = strstr(str, "0x")) != NULL)
    {
        int offset = zerox - str;
        str[offset] = '&';
        strcpy(&str[offset + 1], &str[offset + 2]);
    }
    return str;
}


/*************************************************** Gerph *********
 Function:      lookup_swi
 Description:   Convert SWI number to a string
 Parameters:    swinum = the number to convert
 Returns:       pointer to static string, or NULL if not decodable
 ******************************************************************/
const char *lookup_swi(uint32_t swinum)
{
    static char buffer[128];
    char *result;
    _kernel_oserror *err;
    err = _swix(OS_SWINumberToString, _INR(0, 2), swinum, buffer, sizeof(buffer));
    if (err)
        return NULL;

    result = buffer;
    if (*result == 'X')
        result++;
    if (result[0] == 'U' &&
        result[1] == 's' &&
        result[2] == 'e' &&
        result[3] == 'r' &&
        result[4] == '\0')
    {
        sprintf(buffer, "&%X", swinum);
    }
    return buffer;
}


/*************************************************** Gerph *********
 Function:      disassemble_darm
 Description:   Disassemble a 16bit/32bit work for ARM/Thumb code
 Parameters:    word = the value to disassemble
                address = the address it was at
                thumb = 1 for Thumb code, 0 for ARM code.
 Returns:       pointer to the disassembled string
 ******************************************************************/
const char *disassemble_darm(uint32_t word, uint32_t address, int thumb)
{
    bool ok;
    static char buffer[256];
    const char *comment = NULL;

    ok = disassemble_fpa(address, word, buffer, sizeof(buffer));
    if (ok)
    {
        dprintf("Decoded %08x as a FP instruction\n", word);
        return buffer;
    }

    ok = false;
    if (thumb)
    {
        if (darm_thumb_disasm(&d, (uint16_t)word) == 0)
            ok = true;
    }
    else
    {
        if (darm_armv7_disasm(&d, word) == 0)
            ok = true;
    }
    if (ok)
        dprintf("Decoded ok\n");

    if (ok &&
        darm_str2(&d, &str, 1) == 0) {

        char mnemonic[12];
        char newargs[80];
        const char *args = &str.total[strlen(str.mnemonic) + 1];
        if (args[-1] == '\0')
            args--;
        strcpy(mnemonic, str.mnemonic);
        if (strncmp(mnemonic, "svc", 3) == 0)
        {
            const char *swiname;
            mnemonic[0] = 's';
            mnemonic[1] = 'w';
            mnemonic[2] = 'i';

            /* The SWI number is in the d.imm parameter */
            dprintf("SWI lookup of #%i\n", d.imm);
            swiname = lookup_swi(d.imm);
            if (swiname != NULL)
                args = swiname;
        }
        else if ((strncmp(mnemonic, "ldm", 3) == 0 ||
                  strncmp(mnemonic, "stm", 3) == 0) &&
                 mnemonic[3] != 'i' &&
                 mnemonic[3] != 'd')
        {
            /* LDM, LDMNE, STM, STMNE, etc */
            strcat(mnemonic, "ia");
        }

        if (args[0] == '#' && args[1] == '+')
        {
            /* This is a PC relative instruction like B/BL/BLX (or conditional variant) */
            sprintf(newargs, "&%08x", address + (thumb ? 4 : 8) + d.imm);
            args = newargs;
        }
        if (strncmp(mnemonic, "cbz", 3) == 0 ||
            strncmp(mnemonic, "cbnz", 4) == 0)
        {
            /* This is a PC relative thumb instruction */
            char *hashplus;
            strcpy(newargs, args);
            args = newargs;
            hashplus = strstr(newargs, "#+");
            if (hashplus)
            {
                sprintf(hashplus, "&%08x", address + 4 + d.imm);
            }
        }
        else if (strncmp(mnemonic, "adr", 3) == 0)
        {
            /* This is a ADR with PC relative reference */
            char *hashplus;
            strcpy(newargs, args);
            hashplus = strstr(newargs, "#+");
            if (hashplus)
            {
                uint32_t rounded = address & ~3;
                // https://developer.arm.com/documentation/ddi0403/d/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-ARMv7-M-Thumb-instructions/ADR?lang=en
                // Address alignment is always PC rounded down.
                sprintf(hashplus, "&%08x", d.U ? rounded + (thumb ? 4 : 8) + d.imm
                                               : rounded + (thumb ? 4 : 8) - d.imm);
            }
            args = newargs;
        }
        else if ((strncmp(mnemonic, "ldr", 3) == 0 ||
                  strncmp(mnemonic, "str", 3) == 0) &&
                 strstr(args, "pc, #") != NULL)
        {
            /* This is a LDR/STR with PC relative reference */
            char *bracketpc;
            strcpy(newargs, args);
            bracketpc = strstr(newargs, "[pc");
            if (bracketpc)
            {
                uint32_t rounded = address & ~3;
                // https://developer.arm.com/documentation/ddi0403/d/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-ARMv7-M-Thumb-instructions/LDR--literal-?lang=en
                // https://developer.arm.com/documentation/ddi0403/d/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-ARMv7-M-Thumb-instructions/LDRB--literal-?lang=en
                // Address is always rounded to a word for both LDR and LDRB
                sprintf(bracketpc, "&%08lx", d.U ? rounded + (thumb ? 4 : 8) + d.imm
                                                 : rounded + (thumb ? 4 : 8) - d.imm);
            }
            args = newargs;
        }
        else if ((mnemonic[0] == 'l' && mnemonic[1] == 's' && (mnemonic[2] == 'l' ||
                                                               mnemonic[2] == 'r')) ||
                 (mnemonic[0] == 'a' && mnemonic[1] == 's' && mnemonic[2] == 'r') ||
                 (mnemonic[0] == 'r' && mnemonic[1] == 'o' && (mnemonic[2] == 'l' ||
                                                               mnemonic[2] == 'r')))
        {
            /* Shifts that appear as modern notation ( LSL r0, r0, #3 => MOV r0, r0, LSL #3 ) */
            char *lastcomma = strrchr(args, ',');
            if (lastcomma != NULL && lastcomma[1] == ' ')
            {
                char *write = &newargs[lastcomma + 2 - args]; /* Points to the '#' in the output */
                strcpy(newargs, args);
                *write++ = mnemonic[0];     /* First char of mnemonic */
                *write++ = mnemonic[1];
                *write++ = mnemonic[2];
                strcpy(write, lastcomma + 1);   /* Copy the ' #3' (or register) over */
                strncpy(mnemonic, "MOV", 3);
                args = newargs;
            }
        }
        else if ((mnemonic[0] == 'c' && mnemonic[1] == 'm' && (mnemonic[2] == 'p' ||
                                                               mnemonic[2] == 'n')) ||
                 (mnemonic[0] == 't' && mnemonic[1] == 's' && mnemonic[2] == 't') ||
                 (mnemonic[0] == 't' && mnemonic[1] == 'e' && mnemonic[2] == 'q'))
        {
            /* CMP/CMN/TEQ/TST can have a 'P' on them, IF they have 15 in bits 12-15 */
            uint32_t rd = (word >> 12) & 15;
            if (rd == 15)
                strcat(mnemonic, "P");
        }

        /* Tweak the hex notation */
        if (args != newargs)
            strcpy(newargs, args), args = newargs;
        convert_hex_0x_to_ampersand(newargs);

        /* Ensure mnemonics are in the correct case */
        {
            char *s;
            for (s = mnemonic; *s; s++)
            {
                *s = toupper(*s);
            }
        }

#define MNEMONIC_MATCH(with) (mnemonic[0] == with[0] && mnemonic[1] == with[1] && mnemonic[2] == with[2])

        if ((MNEMONIC_MATCH("MOV") ||
             MNEMONIC_MATCH("MVN") ||
             MNEMONIC_MATCH("CMP") ||
             MNEMONIC_MATCH("CMN") ||
             MNEMONIC_MATCH("TEQ") ||
             MNEMONIC_MATCH("TST") ||
             MNEMONIC_MATCH("ADD") ||
             MNEMONIC_MATCH("SUB") ||
             MNEMONIC_MATCH("RSB") ||
             MNEMONIC_MATCH("ADC") ||
             MNEMONIC_MATCH("SBC") ||
             MNEMONIC_MATCH("RSC") ||
             MNEMONIC_MATCH("ORR") ||
             MNEMONIC_MATCH("AND") ||
             MNEMONIC_MATCH("BIC") ||
             MNEMONIC_MATCH("EOR")))
        {
            // Fix up the ROR, ROL, LSL, LSR, ASR to be capitalised
            char *shift = strstr(args, "ro");
            if (!shift)
            {
                shift = strstr(args, "ls");
            }
            if (shift)
            {
                if (shift[2] == 'r' || shift[2] == 'l')
                {
                    shift[0] &= ~32;
                    shift[1] &= ~32;
                    shift[2] &= ~32;
                }
            }
            else
            {
                shift = strstr(args, "asr");
                if (shift)
                {
                    shift[0] &= ~32;
                    shift[1] &= ~32;
                    shift[2] &= ~32;
                }
            }

            if (strchr(args, '#') != NULL)
            {
                comment = decode_immediate(d.imm, it_positive);

                /* Darm produces 'rrx #0' which isn't correct - RRX is encoded as ROR 0. */
                {
                    char *rrx = strstr(args, "rrx ");
                    if (rrx)
                    {
                        rrx[3] = '\0';
                        // And capitalise
                        rrx[0] &= ~32;
                        rrx[1] &= ~32;
                        rrx[2] &= ~32;
                    }
                }
            }
        }

        if ((MNEMONIC_MATCH("MVN") ||
             MNEMONIC_MATCH("CMN"))
            && strchr(args, '#') != NULL)
            comment = decode_immediate(d.imm, mnemonic[0] == 'M' ? it_negated : it_negative);

        if (comment)
        {
            sprintf(buffer, "%-8s%-26s; %s", mnemonic, args, comment);
        }
        else
        {
            sprintf(buffer, "%-8s%s", mnemonic, args);
        }
    }
    else
    {
        sprintf(buffer, UNDEFINED_INSTRUCTION);
    }

    dprintf("Returning with %s\n", buffer);

    return buffer;
}


/*************************************************** Gerph *********
 Function:      disassemble_armadillo
 Description:   Disassemble a 64bit word for AArch64 code
 Parameters:    word = the value to disassemble
                address = the address it was at
 Returns:       pointer to the disassembled string
 ******************************************************************/
const char *disassemble_armadillo(uint32_t word, uint32_t address)
{
#ifdef DISABLE_ARMADILLO
    return "Crunchy on the outside, smooth on the inside";
#else
    static char buffer[256];
    static char comment[256] = "";
    struct ad_insn *ad = NULL;
    bool failed = ArmadilloDisassemble(word, address, &ad);
    if (failed)
    {
        strcpy(buffer, UNDEFINED_INSTRUCTION);
    }
    else
    {
        /* Successfully disassembled */
        char *in;
        char *out = buffer;

        /* Capitalise the mnemonic */
        for (in = ad->decoded; *in && *in != ' '; in++)
        {
            *out++ = toupper(*in);
        }

        if (*in++ == ' ')
        {
            /* We need to put some spaces in - spaced to 8 characters */
            do {
                *out++ = ' ';
            } while (out < &buffer[8]);

            /* We're now copying the operands */
            strcpy(out, in);
        }

        convert_hex_0x_to_ampersand(buffer);
        out = &buffer[strlen(buffer)];

        {
            char *com = comment;
            int i;
            for(i=0; i < ad->num_operands; i++)
            {
                struct ad_operand *operand = &ad->operands[i];
                if (operand->type == AD_OP_IMM)
                {
                    if (operand->op_imm.type == AD_IMM_INT ||
                        operand->op_imm.type == AD_IMM_UINT ||
                        operand->op_imm.type == AD_IMM_LONG ||
                        operand->op_imm.type == AD_IMM_ULONG) {
                        const char *value;
#ifndef __riscos64
/* FIXME: This is a horrible hack to allow the conversions to work properly on the Norcroft compiler */
#define int64_t int32_t
#define uint64_t uint32_t
#endif
                        uint64_t immediate = operand->op_imm.bits;
                        immtype_t immtype = it_positive;
                        switch (operand->op_imm.type)
                        {
                            case AD_IMM_INT:
                                {
                                    int32_t actual = operand->op_imm.bits;
                                    if (actual < 0)
                                    {
                                        immediate = -actual;
                                        immtype = it_negative;
                                    }
                                    else
                                    {
                                        immediate = actual;
                                    }
                                }
                                break;

                            case AD_IMM_UINT:
                                {
                                    uint32_t actual = operand->op_imm.bits;
                                    immediate = actual;
                                }
                                break;

                            case AD_IMM_LONG:
                                {
                                    int64_t actual = operand->op_imm.bits;
                                    if (actual < 0)
                                    {
                                        immediate = -actual;
                                        immtype = it_negative;
                                    }
                                    else
                                    {
                                        immediate = actual;
                                    }
                                }
                                break;

                            case AD_IMM_ULONG:
                                {
                                    uint64_t actual = operand->op_imm.bits;
                                    immediate = actual;
                                }
                                break;
                        }
                        value = decode_immediate(immediate, immtype);
                        if (value != NULL)
                        {
                            if (com != comment)
                                com += sprintf(com, "; ");
                            com += sprintf(com, "%s", value);
                        }
                    }
                }
            }

            if (com != comment)
            {
                /* There was a comment, so we want to append to our string */
#define COMMENT_OFFSET (8 + 24)

                do {
                    *out++ = ' ';
                } while (out - buffer < COMMENT_OFFSET);
                out += sprintf(out, "; %s", comment);
            }
        }
    }
    ArmadilloDone(&ad);
    return buffer;
#endif
}


/*************************************************** Gerph *********
 Function:      disassemble_memory_arm32
 Description:   Disassemble a 32bit word for ARM code
 Parameters:    data-> the value to disassemble
                datalen = the length to decode
                address = the address it was at
 Returns:       pointer to the disassembled string
 ******************************************************************/
const char *disassemble_memory_arm32(uint8_t *data, int datalen, uint32_t address)
{
    if (datalen != 4)
        return "Invalid length";

    return disassemble_darm(*(uint32_t*)data, address, 0); /* FIXME: Assumes data is aligned */
}


/*************************************************** Gerph *********
 Function:      disassemble_memory_thumb
 Description:   Disassemble a 16bit word for Thumb code
 Parameters:    data-> the value to disassemble
                datalen = the length to decode
                address = the address it was at
 Returns:       pointer to the disassembled string
 ******************************************************************/
const char *disassemble_memory_thumb(uint8_t *data, int datalen, uint32_t address)
{
    if (datalen != 2)
        return "Invalid length";

    return disassemble_darm(*(uint16_t*)data, address, 1); /* FIXME: Assumes data is aligned */
}


/*************************************************** Gerph *********
 Function:      disassemble_memory_arm64
 Description:   Disassemble a 64bit word for AArch64 code
 Parameters:    data-> the value to disassemble
                datalen = the length to decode
                address = the address it was at
 Returns:       pointer to the disassembled string
 ******************************************************************/
const char *disassemble_memory_arm64(uint8_t *data, int datalen, uint32_t address)
{
    if (datalen != 4)
        return "Invalid length";

    return disassemble_armadillo(*(uint32_t*)data, address); /* FIXME: Assumes data is aligned */
}


const char *debugger_disassemble(uint32_t word, uint32_t addr)
{
    return disassemble_darm(*(uint32_t*)word, addr, 0);
}
